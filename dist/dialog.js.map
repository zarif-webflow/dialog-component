{
  "version": 3,
  "sources": ["../bin/live-reload.js", "../node_modules/.pnpm/@taj-wf+utils@1.2.0/node_modules/@taj-wf/utils/dist/index.js", "../node_modules/.pnpm/@zag-js+dom-query@1.15.4/node_modules/@zag-js/dom-query/dist/index.mjs", "../node_modules/.pnpm/@zag-js+remove-scroll@1.15.4/node_modules/@zag-js/remove-scroll/dist/index.mjs", "../src/utils/constants.ts", "../node_modules/.pnpm/@zag-js+utils@1.15.4/node_modules/@zag-js/utils/dist/index.mjs", "../node_modules/.pnpm/@zag-js+interact-outside@1.15.4/node_modules/@zag-js/interact-outside/dist/index.mjs", "../src/utils/animations.ts", "../src/utils/dialog.ts", "../src/features/dialog.ts"],
  "sourcesContent": ["new EventSource(`${SERVE_ORIGIN}/esbuild`).addEventListener(\"change\", () => location.reload());\n", "// src/modules/after-webflow-ready.ts\nvar afterWebflowReady = (callback) => {\n  window.Webflow ||= [];\n  window.Webflow.push(callback);\n};\n\n// src/modules/get-html-element.ts\nvar getHtmlElement = ({\n  selector,\n  parent,\n  log = \"debug\"\n}) => {\n  const targetElement = (parent || document).querySelector(selector);\n  if (targetElement === null) {\n    if (log === false) return null;\n    const consoleMethod = log === \"debug\" ? console.debug : console.error;\n    consoleMethod(\n      `${log.toUpperCase()}: Element with selector \"${selector}\" not found in ${parent !== void 0 ? \"the specified parent element:\" : \"the document.\"}`,\n      parent\n    );\n    return null;\n  }\n  return targetElement;\n};\nvar getMultipleHtmlElements = ({\n  selector,\n  parent,\n  log = \"debug\"\n}) => {\n  const targetElements = Array.from((parent || document).querySelectorAll(selector));\n  if (targetElements.length === 0) {\n    if (log === false) return null;\n    const consoleMethod = log === \"debug\" ? console.debug : console.error;\n    consoleMethod(\n      `${log.toUpperCase()}: No elements found with selector \"${selector}\" in ${parent !== void 0 ? \"the specified parent element:\" : \"the document.\"}`,\n      parent\n    );\n    return null;\n  }\n  return targetElements;\n};\n\n// src/modules/get-active-script.ts\nvar getActiveScript = () => {\n  const currentModuleUrl = import.meta.url;\n  return getHtmlElement({\n    selector: `script[src=\"${currentModuleUrl}\"]`\n  });\n};\n\n// src/modules/get-gsap.ts\nvar getGsap = (plugins = [], log) => {\n  let gsapInstance = null;\n  const logFunc = log === \"debug\" ? console.debug : log === \"error\" ? console.error : null;\n  try {\n    gsapInstance = gsap;\n  } catch {\n    logFunc?.(\n      \"GSAP script needs to be imported before this script:\",\n      getActiveScript(),\n      \"\\n\",\n      \"Get GSAP from here: https://gsap.com/docs/v3/Installation/ \"\n    );\n  }\n  const result = [gsapInstance];\n  for (let i = 0; i < plugins.length; i++) {\n    const plugin = plugins[i];\n    let pluginInstance = null;\n    try {\n      pluginInstance = window[plugin] || null;\n      if (pluginInstance === null) {\n        throw new Error();\n      }\n    } catch {\n      logFunc?.(\n        `${plugin} plugin script needs to be imported before this script.`,\n        getActiveScript(),\n        \"\\n\",\n        `Get ${plugin} plugin from here: https://gsap.com/docs/v3/Installation/ `\n      );\n    }\n    result[i + 1] = pluginInstance;\n  }\n  return result;\n};\n\n// src/modules/set-style.ts\nvar setStyle = (element, styles) => {\n  const prevValues = {};\n  for (const key of Object.keys(styles)) {\n    prevValues[key] = element.style[key];\n    element.style[key] = styles[key] || \"\";\n  }\n  return {\n    revert: () => {\n      Object.assign(element.style, prevValues);\n    }\n  };\n};\n\n// src/modules/wf-custom-page-load-features.ts\nwindow.wfCustomPageLoadFeatures ||= [];\nvar addWFCustomPageLoadFeature = (feature) => {\n  window.wfCustomPageLoadFeatures ||= [];\n  window.wfCustomPageLoadFeatures.push(feature);\n};\nvar getWFCustomPageLoadFeatures = () => window.wfCustomPageLoadFeatures;\nvar getWFCustomPageLoadFeatureByName = (name) => window.wfCustomPageLoadFeatures.find((feature) => feature.name === name) || null;\n\nexport { addWFCustomPageLoadFeature, afterWebflowReady, getActiveScript, getGsap, getHtmlElement, getMultipleHtmlElements, getWFCustomPageLoadFeatureByName, getWFCustomPageLoadFeatures, setStyle };\n", "// src/caret.ts\nfunction isCaretAtStart(input) {\n  if (!input) return false;\n  try {\n    return input.selectionStart === 0 && input.selectionEnd === 0;\n  } catch {\n    return input.value === \"\";\n  }\n}\nfunction setCaretToEnd(input) {\n  if (!input) return;\n  const start = input.selectionStart ?? 0;\n  const end = input.selectionEnd ?? 0;\n  if (Math.abs(end - start) !== 0) return;\n  if (start !== 0) return;\n  input.setSelectionRange(input.value.length, input.value.length);\n}\n\n// src/shared.ts\nvar clamp = (value) => Math.max(0, Math.min(1, value));\nvar wrap = (v, idx) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);\n};\nvar pipe = (...fns) => (arg) => fns.reduce((acc, fn) => fn(acc), arg);\nvar noop = () => void 0;\nvar isObject = (v) => typeof v === \"object\" && v !== null;\nvar MAX_Z_INDEX = 2147483647;\nvar dataAttr = (guard) => guard ? \"\" : void 0;\nvar ariaAttr = (guard) => guard ? \"true\" : void 0;\n\n// src/node.ts\nvar ELEMENT_NODE = 1;\nvar DOCUMENT_NODE = 9;\nvar DOCUMENT_FRAGMENT_NODE = 11;\nvar isHTMLElement = (el) => isObject(el) && el.nodeType === ELEMENT_NODE && typeof el.nodeName === \"string\";\nvar isDocument = (el) => isObject(el) && el.nodeType === DOCUMENT_NODE;\nvar isWindow = (el) => isObject(el) && el === el.window;\nvar isVisualViewport = (el) => isObject(el) && el.constructor.name === \"VisualViewport\";\nvar getNodeName = (node) => {\n  if (isHTMLElement(node)) return node.localName || \"\";\n  return \"#document\";\n};\nfunction isRootElement(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nvar isNode = (el) => isObject(el) && el.nodeType !== void 0;\nvar isShadowRoot = (el) => isNode(el) && el.nodeType === DOCUMENT_FRAGMENT_NODE && \"host\" in el;\nvar isInputElement = (el) => isHTMLElement(el) && el.localName === \"input\";\nvar isAnchorElement = (el) => !!el?.matches(\"a[href]\");\nvar isElementVisible = (el) => {\n  if (!isHTMLElement(el)) return false;\n  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;\n};\nvar TEXTAREA_SELECT_REGEX = /(textarea|select)/;\nfunction isEditableElement(el) {\n  if (el == null || !isHTMLElement(el)) return false;\n  try {\n    return isInputElement(el) && el.selectionStart != null || TEXTAREA_SELECT_REGEX.test(el.localName) || el.isContentEditable || el.getAttribute(\"contenteditable\") === \"true\" || el.getAttribute(\"contenteditable\") === \"\";\n  } catch {\n    return false;\n  }\n}\nfunction contains(parent, child) {\n  if (!parent || !child) return false;\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;\n  const rootNode = child.getRootNode?.();\n  if (parent === child) return true;\n  if (parent.contains(child)) return true;\n  if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) return true;\n      next = next.parentNode || next.host;\n    }\n  }\n  return false;\n}\nfunction getDocument(el) {\n  if (isDocument(el)) return el;\n  if (isWindow(el)) return el.document;\n  return el?.ownerDocument ?? document;\n}\nfunction getDocumentElement(el) {\n  return getDocument(el).documentElement;\n}\nfunction getWindow(el) {\n  if (isShadowRoot(el)) return getWindow(el.host);\n  if (isDocument(el)) return el.defaultView ?? window;\n  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window;\n  return window;\n}\nfunction getActiveElement(rootNode) {\n  let activeElement = rootNode.activeElement;\n  while (activeElement?.shadowRoot) {\n    const el = activeElement.shadowRoot.activeElement;\n    if (el === activeElement) break;\n    else activeElement = el;\n  }\n  return activeElement;\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") return node;\n  const result = node.assignedSlot || node.parentNode || isShadowRoot(node) && node.host || getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\n// src/computed-style.ts\nvar styleCache = /* @__PURE__ */ new WeakMap();\nfunction getComputedStyle(el) {\n  if (!styleCache.has(el)) {\n    styleCache.set(el, getWindow(el).getComputedStyle(el));\n  }\n  return styleCache.get(el);\n}\n\n// src/data-url.ts\nfunction getDataUrl(svg, opts) {\n  const { type, quality = 0.92, background } = opts;\n  if (!svg) throw new Error(\"[zag-js > getDataUrl]: Could not find the svg element\");\n  const win = getWindow(svg);\n  const doc = win.document;\n  const svgBounds = svg.getBoundingClientRect();\n  const svgClone = svg.cloneNode(true);\n  if (!svgClone.hasAttribute(\"viewBox\")) {\n    svgClone.setAttribute(\"viewBox\", `0 0 ${svgBounds.width} ${svgBounds.height}`);\n  }\n  const serializer = new win.XMLSerializer();\n  const source = '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n' + serializer.serializeToString(svgClone);\n  const svgString = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(source);\n  if (type === \"image/svg+xml\") {\n    return Promise.resolve(svgString).then((str) => {\n      svgClone.remove();\n      return str;\n    });\n  }\n  const dpr = win.devicePixelRatio || 1;\n  const canvas = doc.createElement(\"canvas\");\n  const image = new win.Image();\n  image.src = svgString;\n  canvas.width = svgBounds.width * dpr;\n  canvas.height = svgBounds.height * dpr;\n  const context = canvas.getContext(\"2d\");\n  if (type === \"image/jpeg\" || background) {\n    context.fillStyle = background || \"white\";\n    context.fillRect(0, 0, canvas.width, canvas.height);\n  }\n  return new Promise((resolve) => {\n    image.onload = () => {\n      context?.drawImage(image, 0, 0, canvas.width, canvas.height);\n      resolve(canvas.toDataURL(type, quality));\n      svgClone.remove();\n    };\n  });\n}\n\n// src/platform.ts\nvar isDom = () => typeof document !== \"undefined\";\nfunction getPlatform() {\n  const agent = navigator.userAgentData;\n  return agent?.platform ?? navigator.platform;\n}\nfunction getUserAgent() {\n  const ua2 = navigator.userAgentData;\n  if (ua2 && Array.isArray(ua2.brands)) {\n    return ua2.brands.map(({ brand, version }) => `${brand}/${version}`).join(\" \");\n  }\n  return navigator.userAgent;\n}\nvar pt = (v) => isDom() && v.test(getPlatform());\nvar ua = (v) => isDom() && v.test(getUserAgent());\nvar vn = (v) => isDom() && v.test(navigator.vendor);\nvar isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;\nvar isIPhone = () => pt(/^iPhone/i);\nvar isIPad = () => pt(/^iPad/i) || isMac() && navigator.maxTouchPoints > 1;\nvar isIos = () => isIPhone() || isIPad();\nvar isApple = () => isMac() || isIos();\nvar isMac = () => pt(/^Mac/i);\nvar isSafari = () => isApple() && vn(/apple/i);\nvar isFirefox = () => ua(/Firefox/i);\nvar isChrome = () => ua(/Chrome/i);\nvar isWebKit = () => ua(/AppleWebKit/i) && !isChrome();\nvar isAndroid = () => ua(/Android/i);\n\n// src/event.ts\nfunction getBeforeInputValue(event) {\n  const { selectionStart, selectionEnd, value } = event.currentTarget;\n  return value.slice(0, selectionStart) + event.data + value.slice(selectionEnd);\n}\nfunction getComposedPath(event) {\n  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.();\n}\nfunction getEventTarget(event) {\n  const composedPath = getComposedPath(event);\n  return composedPath?.[0] ?? event.target;\n}\nvar isSelfTarget = (event) => {\n  return contains(event.currentTarget, getEventTarget(event));\n};\nfunction isOpeningInNewTab(event) {\n  const element = event.currentTarget;\n  if (!element) return false;\n  const validElement = element.matches(\"a[href], button[type='submit'], input[type='submit']\");\n  if (!validElement) return false;\n  const isMiddleClick = event.button === 1;\n  const isModKeyClick = isCtrlOrMetaKey(event);\n  return isMiddleClick || isModKeyClick;\n}\nfunction isDownloadingEvent(event) {\n  const element = event.currentTarget;\n  if (!element) return false;\n  const localName = element.localName;\n  if (!event.altKey) return false;\n  if (localName === \"a\") return true;\n  if (localName === \"button\" && element.type === \"submit\") return true;\n  if (localName === \"input\" && element.type === \"submit\") return true;\n  return false;\n}\nfunction isComposingEvent(event) {\n  return getNativeEvent(event).isComposing || event.keyCode === 229;\n}\nfunction isKeyboardClick(e) {\n  return e.detail === 0 || e.clientX === 0 && e.clientY === 0;\n}\nfunction isCtrlOrMetaKey(e) {\n  if (isMac()) return e.metaKey;\n  return e.ctrlKey;\n}\nfunction isPrintableKey(e) {\n  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;\n}\nfunction isVirtualPointerEvent(e) {\n  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === \"mouse\";\n}\nfunction isVirtualClick(e) {\n  if (e.mozInputSource === 0 && e.isTrusted) return true;\n  if (isAndroid() && e.pointerType) {\n    return e.type === \"click\" && e.buttons === 1;\n  }\n  return e.detail === 0 && !e.pointerType;\n}\nvar isLeftClick = (e) => e.button === 0;\nvar isContextMenuEvent = (e) => {\n  return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;\n};\nvar isModifierKey = (e) => e.ctrlKey || e.altKey || e.metaKey;\nvar isTouchEvent = (event) => \"touches\" in event && event.touches.length > 0;\nvar keyMap = {\n  Up: \"ArrowUp\",\n  Down: \"ArrowDown\",\n  Esc: \"Escape\",\n  \" \": \"Space\",\n  \",\": \"Comma\",\n  Left: \"ArrowLeft\",\n  Right: \"ArrowRight\"\n};\nvar rtlKeyMap = {\n  ArrowLeft: \"ArrowRight\",\n  ArrowRight: \"ArrowLeft\"\n};\nfunction getEventKey(event, options = {}) {\n  const { dir = \"ltr\", orientation = \"horizontal\" } = options;\n  let key = event.key;\n  key = keyMap[key] ?? key;\n  const isRtl = dir === \"rtl\" && orientation === \"horizontal\";\n  if (isRtl && key in rtlKeyMap) key = rtlKeyMap[key];\n  return key;\n}\nfunction getNativeEvent(event) {\n  return event.nativeEvent ?? event;\n}\nvar pageKeys = /* @__PURE__ */ new Set([\"PageUp\", \"PageDown\"]);\nvar arrowKeys = /* @__PURE__ */ new Set([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"]);\nfunction getEventStep(event) {\n  if (event.ctrlKey || event.metaKey) {\n    return 0.1;\n  } else {\n    const isPageKey = pageKeys.has(event.key);\n    const isSkipKey = isPageKey || event.shiftKey && arrowKeys.has(event.key);\n    return isSkipKey ? 10 : 1;\n  }\n}\nfunction getEventPoint(event, type = \"client\") {\n  const point = isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;\n  return { x: point[`${type}X`], y: point[`${type}Y`] };\n}\nvar addDomEvent = (target, eventName, handler, options) => {\n  const node = typeof target === \"function\" ? target() : target;\n  node?.addEventListener(eventName, handler, options);\n  return () => {\n    node?.removeEventListener(eventName, handler, options);\n  };\n};\n\n// src/form.ts\nfunction getDescriptor(el, options) {\n  const { type = \"HTMLInputElement\", property = \"value\" } = options;\n  const proto = getWindow(el)[type].prototype;\n  return Object.getOwnPropertyDescriptor(proto, property) ?? {};\n}\nfunction getElementType(el) {\n  if (el.localName === \"input\") return \"HTMLInputElement\";\n  if (el.localName === \"textarea\") return \"HTMLTextAreaElement\";\n  if (el.localName === \"select\") return \"HTMLSelectElement\";\n}\nfunction setElementValue(el, value, property = \"value\") {\n  if (!el) return;\n  const type = getElementType(el);\n  if (type) {\n    const descriptor = getDescriptor(el, { type, property });\n    descriptor.set?.call(el, value);\n  }\n  el.setAttribute(property, value);\n}\nfunction setElementChecked(el, checked) {\n  if (!el) return;\n  const descriptor = getDescriptor(el, { type: \"HTMLInputElement\", property: \"checked\" });\n  descriptor.set?.call(el, checked);\n  if (checked) el.setAttribute(\"checked\", \"\");\n  else el.removeAttribute(\"checked\");\n}\nfunction dispatchInputValueEvent(el, options) {\n  const { value, bubbles = true } = options;\n  if (!el) return;\n  const win = getWindow(el);\n  if (!(el instanceof win.HTMLInputElement)) return;\n  setElementValue(el, `${value}`);\n  el.dispatchEvent(new win.Event(\"input\", { bubbles }));\n}\nfunction dispatchInputCheckedEvent(el, options) {\n  const { checked, bubbles = true } = options;\n  if (!el) return;\n  const win = getWindow(el);\n  if (!(el instanceof win.HTMLInputElement)) return;\n  setElementChecked(el, checked);\n  el.dispatchEvent(new win.Event(\"click\", { bubbles }));\n}\nfunction getClosestForm(el) {\n  return isFormElement(el) ? el.form : el.closest(\"form\");\n}\nfunction isFormElement(el) {\n  return el.matches(\"textarea, input, select, button\");\n}\nfunction trackFormReset(el, callback) {\n  if (!el) return;\n  const form = getClosestForm(el);\n  const onReset = (e) => {\n    if (e.defaultPrevented) return;\n    callback();\n  };\n  form?.addEventListener(\"reset\", onReset, { passive: true });\n  return () => form?.removeEventListener(\"reset\", onReset);\n}\nfunction trackFieldsetDisabled(el, callback) {\n  const fieldset = el?.closest(\"fieldset\");\n  if (!fieldset) return;\n  callback(fieldset.disabled);\n  const win = getWindow(fieldset);\n  const obs = new win.MutationObserver(() => callback(fieldset.disabled));\n  obs.observe(fieldset, {\n    attributes: true,\n    attributeFilter: [\"disabled\"]\n  });\n  return () => obs.disconnect();\n}\nfunction trackFormControl(el, options) {\n  if (!el) return;\n  const { onFieldsetDisabledChange, onFormReset } = options;\n  const cleanups = [trackFormReset(el, onFormReset), trackFieldsetDisabled(el, onFieldsetDisabledChange)];\n  return () => cleanups.forEach((cleanup) => cleanup?.());\n}\n\n// src/tabbable.ts\nvar isFrame = (el) => isHTMLElement(el) && el.tagName === \"IFRAME\";\nvar hasTabIndex = (el) => !Number.isNaN(parseInt(el.getAttribute(\"tabindex\") || \"0\", 10));\nvar hasNegativeTabIndex = (el) => parseInt(el.getAttribute(\"tabindex\") || \"0\", 10) < 0;\nvar focusableSelector = \"input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type\";\nvar getFocusables = (container, includeContainer = false) => {\n  if (!container) return [];\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  const include = includeContainer == true || includeContainer == \"if-empty\" && elements.length === 0;\n  if (include && isHTMLElement(container) && isFocusable(container)) {\n    elements.unshift(container);\n  }\n  const focusableElements = elements.filter(isFocusable);\n  focusableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      focusableElements.splice(i, 1, ...getFocusables(frameBody));\n    }\n  });\n  return focusableElements;\n};\nfunction isFocusable(element) {\n  if (!element || element.closest(\"[inert]\")) return false;\n  return element.matches(focusableSelector) && isElementVisible(element);\n}\nfunction getFirstFocusable(container, includeContainer) {\n  const [first] = getFocusables(container, includeContainer);\n  return first || null;\n}\nfunction getTabbables(container, includeContainer) {\n  if (!container) return [];\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  const tabbableElements = elements.filter(isTabbable);\n  if (includeContainer && isTabbable(container)) {\n    tabbableElements.unshift(container);\n  }\n  tabbableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      const allFrameTabbable = getTabbables(frameBody);\n      tabbableElements.splice(i, 1, ...allFrameTabbable);\n    }\n  });\n  if (!tabbableElements.length && includeContainer) {\n    return elements;\n  }\n  return tabbableElements;\n}\nfunction isTabbable(el) {\n  if (el != null && el.tabIndex > 0) return true;\n  return isFocusable(el) && !hasNegativeTabIndex(el);\n}\nfunction getFirstTabbable(container, includeContainer) {\n  const [first] = getTabbables(container, includeContainer);\n  return first || null;\n}\nfunction getLastTabbable(container, includeContainer) {\n  const elements = getTabbables(container, includeContainer);\n  return elements[elements.length - 1] || null;\n}\nfunction getTabbableEdges(container, includeContainer) {\n  const elements = getTabbables(container, includeContainer);\n  const first = elements[0] || null;\n  const last = elements[elements.length - 1] || null;\n  return [first, last];\n}\nfunction getNextTabbable(container, current) {\n  const tabbables = getTabbables(container);\n  const doc = container?.ownerDocument || document;\n  const currentElement = current ?? doc.activeElement;\n  if (!currentElement) return null;\n  const index = tabbables.indexOf(currentElement);\n  return tabbables[index + 1] || null;\n}\nfunction getTabIndex(node) {\n  if (node.tabIndex < 0) {\n    if ((/^(audio|video|details)$/.test(node.localName) || isEditableElement(node)) && !hasTabIndex(node)) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n}\n\n// src/initial-focus.ts\nfunction getInitialFocus(options) {\n  const { root, getInitialEl, filter, enabled = true } = options;\n  if (!enabled) return;\n  let node = null;\n  node || (node = typeof getInitialEl === \"function\" ? getInitialEl() : getInitialEl);\n  node || (node = root?.querySelector(\"[data-autofocus],[autofocus]\"));\n  if (!node) {\n    const tabbables = getTabbables(root);\n    node = filter ? tabbables.filter(filter)[0] : tabbables[0];\n  }\n  return node || root || void 0;\n}\nfunction isValidTabEvent(event) {\n  const container = event.currentTarget;\n  if (!container) return false;\n  const [firstTabbable, lastTabbable] = getTabbableEdges(container);\n  const doc = container.ownerDocument || document;\n  if (doc.activeElement === firstTabbable && event.shiftKey) return false;\n  if (doc.activeElement === lastTabbable && !event.shiftKey) return false;\n  if (!firstTabbable && !lastTabbable) return false;\n  return true;\n}\n\n// src/raf.ts\nfunction nextTick(fn) {\n  const set = /* @__PURE__ */ new Set();\n  function raf2(fn2) {\n    const id = globalThis.requestAnimationFrame(fn2);\n    set.add(() => globalThis.cancelAnimationFrame(id));\n  }\n  raf2(() => raf2(fn));\n  return function cleanup() {\n    set.forEach((fn2) => fn2());\n  };\n}\nfunction raf(fn) {\n  let cleanup;\n  const id = globalThis.requestAnimationFrame(() => {\n    cleanup = fn();\n  });\n  return () => {\n    globalThis.cancelAnimationFrame(id);\n    cleanup?.();\n  };\n}\nfunction queueBeforeEvent(el, type, cb) {\n  const cancelTimer = raf(() => {\n    el.removeEventListener(type, exec, true);\n    cb();\n  });\n  const exec = () => {\n    cancelTimer();\n    cb();\n  };\n  el.addEventListener(type, exec, { once: true, capture: true });\n  return cancelTimer;\n}\n\n// src/mutation-observer.ts\nfunction observeAttributesImpl(node, options) {\n  if (!node) return;\n  const { attributes, callback: fn } = options;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver((changes) => {\n    for (const change of changes) {\n      if (change.type === \"attributes\" && change.attributeName && attributes.includes(change.attributeName)) {\n        fn(change);\n      }\n    }\n  });\n  obs.observe(node, { attributes: true, attributeFilter: attributes });\n  return () => obs.disconnect();\n}\nfunction observeAttributes(nodeOrFn, options) {\n  const { defer } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n      cleanups.push(observeAttributesImpl(node, options));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\nfunction observeChildrenImpl(node, options) {\n  const { callback: fn } = options;\n  if (!node) return;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver(fn);\n  obs.observe(node, { childList: true, subtree: true });\n  return () => obs.disconnect();\n}\nfunction observeChildren(nodeOrFn, options) {\n  const { defer } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n      cleanups.push(observeChildrenImpl(node, options));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\n\n// src/navigate.ts\nfunction clickIfLink(el) {\n  const click = () => {\n    const win = getWindow(el);\n    el.dispatchEvent(new win.MouseEvent(\"click\"));\n  };\n  if (isFirefox()) {\n    queueBeforeEvent(el, \"keyup\", click);\n  } else {\n    queueMicrotask(click);\n  }\n}\n\n// src/overflow.ts\nfunction getNearestOverflowAncestor(el) {\n  const parentNode = getParentNode(el);\n  if (isRootElement(parentNode)) return getDocument(parentNode).body;\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) return parentNode;\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(el, list = []) {\n  const scrollableAncestor = getNearestOverflowAncestor(el);\n  const isBody = scrollableAncestor === el.ownerDocument.body;\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));\n}\nvar getElementRect = (el) => {\n  if (isHTMLElement(el)) return el.getBoundingClientRect();\n  if (isVisualViewport(el)) return { top: 0, left: 0, bottom: el.height, right: el.width };\n  return { top: 0, left: 0, bottom: el.innerHeight, right: el.innerWidth };\n};\nfunction isInView(el, ancestor) {\n  if (!isHTMLElement(el)) return true;\n  const ancestorRect = getElementRect(ancestor);\n  const elRect = el.getBoundingClientRect();\n  return elRect.top >= ancestorRect.top && elRect.left >= ancestorRect.left && elRect.bottom <= ancestorRect.bottom && elRect.right <= ancestorRect.right;\n}\nvar OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;\nfunction isOverflowElement(el) {\n  const win = getWindow(el);\n  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);\n  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display);\n}\nfunction isScrollable(el) {\n  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;\n}\nfunction scrollIntoView(el, options) {\n  const { rootEl, ...scrollOptions } = options || {};\n  if (!el || !rootEl) return;\n  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) return;\n  el.scrollIntoView(scrollOptions);\n}\nfunction getScrollPosition(element) {\n  if (isHTMLElement(element)) {\n    return { scrollLeft: element.scrollLeft, scrollTop: element.scrollTop };\n  }\n  return { scrollLeft: element.scrollX, scrollTop: element.scrollY };\n}\n\n// src/point.ts\nfunction getRelativePoint(point, element) {\n  const { left, top, width, height } = element.getBoundingClientRect();\n  const offset = { x: point.x - left, y: point.y - top };\n  const percent = { x: clamp(offset.x / width), y: clamp(offset.y / height) };\n  function getPercentValue(options = {}) {\n    const { dir = \"ltr\", orientation = \"horizontal\", inverted } = options;\n    const invertX = typeof inverted === \"object\" ? inverted.x : inverted;\n    const invertY = typeof inverted === \"object\" ? inverted.y : inverted;\n    if (orientation === \"horizontal\") {\n      return dir === \"rtl\" || invertX ? 1 - percent.x : percent.x;\n    }\n    return invertY ? 1 - percent.y : percent.y;\n  }\n  return { offset, percent, getPercentValue };\n}\n\n// src/pointer-lock.ts\nfunction requestPointerLock(doc, fn) {\n  const body = doc.body;\n  const supported = \"pointerLockElement\" in doc || \"mozPointerLockElement\" in doc;\n  const isLocked = () => !!doc.pointerLockElement;\n  function onPointerChange() {\n    fn?.(isLocked());\n  }\n  function onPointerError(event) {\n    if (isLocked()) fn?.(false);\n    console.error(\"PointerLock error occurred:\", event);\n    doc.exitPointerLock();\n  }\n  if (!supported) return;\n  try {\n    body.requestPointerLock();\n  } catch {\n  }\n  const cleanup = [\n    addDomEvent(doc, \"pointerlockchange\", onPointerChange, false),\n    addDomEvent(doc, \"pointerlockerror\", onPointerError, false)\n  ];\n  return () => {\n    cleanup.forEach((cleanup2) => cleanup2());\n    doc.exitPointerLock();\n  };\n}\n\n// src/text-selection.ts\nvar state = \"default\";\nvar userSelect = \"\";\nvar elementMap = /* @__PURE__ */ new WeakMap();\nfunction disableTextSelectionImpl(options = {}) {\n  const { target, doc } = options;\n  const docNode = doc ?? document;\n  const rootEl = docNode.documentElement;\n  if (isIos()) {\n    if (state === \"default\") {\n      userSelect = rootEl.style.webkitUserSelect;\n      rootEl.style.webkitUserSelect = \"none\";\n    }\n    state = \"disabled\";\n  } else if (target) {\n    elementMap.set(target, target.style.userSelect);\n    target.style.userSelect = \"none\";\n  }\n  return () => restoreTextSelection({ target, doc: docNode });\n}\nfunction restoreTextSelection(options = {}) {\n  const { target, doc } = options;\n  const docNode = doc ?? document;\n  const rootEl = docNode.documentElement;\n  if (isIos()) {\n    if (state !== \"disabled\") return;\n    state = \"restoring\";\n    setTimeout(() => {\n      nextTick(() => {\n        if (state === \"restoring\") {\n          if (rootEl.style.webkitUserSelect === \"none\") {\n            rootEl.style.webkitUserSelect = userSelect || \"\";\n          }\n          userSelect = \"\";\n          state = \"default\";\n        }\n      });\n    }, 300);\n  } else {\n    if (target && elementMap.has(target)) {\n      const prevUserSelect = elementMap.get(target);\n      if (target.style.userSelect === \"none\") {\n        target.style.userSelect = prevUserSelect ?? \"\";\n      }\n      if (target.getAttribute(\"style\") === \"\") {\n        target.removeAttribute(\"style\");\n      }\n      elementMap.delete(target);\n    }\n  }\n}\nfunction disableTextSelection(options = {}) {\n  const { defer, target, ...restOptions } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const node = typeof target === \"function\" ? target() : target;\n      cleanups.push(disableTextSelectionImpl({ ...restOptions, target: node }));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\n\n// src/pointer-move.ts\nfunction trackPointerMove(doc, handlers) {\n  const { onPointerMove, onPointerUp } = handlers;\n  const handleMove = (event) => {\n    const point = getEventPoint(event);\n    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);\n    const moveBuffer = event.pointerType === \"touch\" ? 10 : 5;\n    if (distance < moveBuffer) return;\n    if (event.pointerType === \"mouse\" && event.button === 0) {\n      onPointerUp();\n      return;\n    }\n    onPointerMove({ point, event });\n  };\n  const cleanups = [\n    addDomEvent(doc, \"pointermove\", handleMove, false),\n    addDomEvent(doc, \"pointerup\", onPointerUp, false),\n    addDomEvent(doc, \"pointercancel\", onPointerUp, false),\n    addDomEvent(doc, \"contextmenu\", onPointerUp, false),\n    disableTextSelection({ doc })\n  ];\n  return () => {\n    cleanups.forEach((cleanup) => cleanup());\n  };\n}\n\n// src/press.ts\nfunction trackPress(options) {\n  const {\n    pointerNode,\n    keyboardNode = pointerNode,\n    onPress,\n    onPressStart,\n    onPressEnd,\n    isValidKey = (e) => e.key === \"Enter\"\n  } = options;\n  if (!pointerNode) return noop;\n  const win = getWindow(pointerNode);\n  const doc = getDocument(pointerNode);\n  let removeStartListeners = noop;\n  let removeEndListeners = noop;\n  let removeAccessibleListeners = noop;\n  const getInfo = (event) => ({\n    point: getEventPoint(event),\n    event\n  });\n  function startPress(event) {\n    onPressStart?.(getInfo(event));\n  }\n  function cancelPress(event) {\n    onPressEnd?.(getInfo(event));\n  }\n  const startPointerPress = (startEvent) => {\n    removeEndListeners();\n    const endPointerPress = (endEvent) => {\n      const target = getEventTarget(endEvent);\n      if (contains(pointerNode, target)) {\n        onPress?.(getInfo(endEvent));\n      } else {\n        onPressEnd?.(getInfo(endEvent));\n      }\n    };\n    const removePointerUpListener = addDomEvent(win, \"pointerup\", endPointerPress, { passive: !onPress, once: true });\n    const removePointerCancelListener = addDomEvent(win, \"pointercancel\", cancelPress, {\n      passive: !onPressEnd,\n      once: true\n    });\n    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);\n    if (doc.activeElement === keyboardNode && startEvent.pointerType === \"mouse\") {\n      startEvent.preventDefault();\n    }\n    startPress(startEvent);\n  };\n  const removePointerListener = addDomEvent(pointerNode, \"pointerdown\", startPointerPress, { passive: !onPressStart });\n  const removeFocusListener = addDomEvent(keyboardNode, \"focus\", startAccessiblePress);\n  removeStartListeners = pipe(removePointerListener, removeFocusListener);\n  function startAccessiblePress() {\n    const handleKeydown = (keydownEvent) => {\n      if (!isValidKey(keydownEvent)) return;\n      const handleKeyup = (keyupEvent) => {\n        if (!isValidKey(keyupEvent)) return;\n        const evt2 = new win.PointerEvent(\"pointerup\");\n        const info = getInfo(evt2);\n        onPress?.(info);\n        onPressEnd?.(info);\n      };\n      removeEndListeners();\n      removeEndListeners = addDomEvent(keyboardNode, \"keyup\", handleKeyup);\n      const evt = new win.PointerEvent(\"pointerdown\");\n      startPress(evt);\n    };\n    const handleBlur = () => {\n      const evt = new win.PointerEvent(\"pointercancel\");\n      cancelPress(evt);\n    };\n    const removeKeydownListener = addDomEvent(keyboardNode, \"keydown\", handleKeydown);\n    const removeBlurListener = addDomEvent(keyboardNode, \"blur\", handleBlur);\n    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);\n  }\n  return () => {\n    removeStartListeners();\n    removeEndListeners();\n    removeAccessibleListeners();\n  };\n}\n\n// src/proxy-tab-focus.ts\nfunction proxyTabFocusImpl(container, options = {}) {\n  const { triggerElement, onFocus, onFocusEnter } = options;\n  const doc = container?.ownerDocument || document;\n  const body = doc.body;\n  function onKeyDown(event) {\n    if (event.key !== \"Tab\") return;\n    let elementToFocus = null;\n    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true);\n    const nextTabbableAfterTrigger = getNextTabbable(body, triggerElement);\n    const noTabbableElements = !firstTabbable && !lastTabbable;\n    if (event.shiftKey && nextTabbableAfterTrigger === doc.activeElement) {\n      onFocusEnter?.();\n      elementToFocus = lastTabbable;\n    } else if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {\n      elementToFocus = triggerElement;\n    } else if (!event.shiftKey && doc.activeElement === triggerElement) {\n      onFocusEnter?.();\n      elementToFocus = firstTabbable;\n    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {\n      elementToFocus = nextTabbableAfterTrigger;\n    }\n    if (!elementToFocus) return;\n    event.preventDefault();\n    if (typeof onFocus === \"function\") {\n      onFocus(elementToFocus);\n    } else {\n      elementToFocus.focus();\n    }\n  }\n  return addDomEvent(doc, \"keydown\", onKeyDown, true);\n}\nfunction proxyTabFocus(container, options) {\n  const { defer, triggerElement, ...restOptions } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const node = typeof container === \"function\" ? container() : container;\n      const trigger = typeof triggerElement === \"function\" ? triggerElement() : triggerElement;\n      cleanups.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\n\n// src/query.ts\nfunction queryAll(root, selector) {\n  return Array.from(root?.querySelectorAll(selector) ?? []);\n}\nfunction query(root, selector) {\n  return root?.querySelector(selector) ?? null;\n}\nvar defaultItemToId = (v) => v.id;\nfunction itemById(v, id, itemToId = defaultItemToId) {\n  return v.find((item) => itemToId(item) === id);\n}\nfunction indexOfId(v, id, itemToId = defaultItemToId) {\n  const item = itemById(v, id, itemToId);\n  return item ? v.indexOf(item) : -1;\n}\nfunction nextById(v, id, loop = true) {\n  let idx = indexOfId(v, id);\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);\n  return v[idx];\n}\nfunction prevById(v, id, loop = true) {\n  let idx = indexOfId(v, id);\n  if (idx === -1) return loop ? v[v.length - 1] : null;\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);\n  return v[idx];\n}\n\n// src/resize-observer.ts\nfunction trackElementRect(elements, options) {\n  const { onEntry, measure, box = \"border-box\" } = options;\n  const elems = (Array.isArray(elements) ? elements : [elements]).filter(isHTMLElement);\n  const win = getWindow(elems[0]);\n  const trigger = (entries) => {\n    const rects = elems.map((el) => measure(el));\n    onEntry({ rects, entries });\n  };\n  trigger([]);\n  const obs = new win.ResizeObserver(trigger);\n  elems.forEach((el) => obs.observe(el, { box }));\n  return () => obs.disconnect();\n}\n\n// src/scope.ts\nfunction createScope(methods) {\n  const dom = {\n    getRootNode: (ctx) => ctx.getRootNode?.() ?? document,\n    getDoc: (ctx) => getDocument(dom.getRootNode(ctx)),\n    getWin: (ctx) => dom.getDoc(ctx).defaultView ?? window,\n    getActiveElement: (ctx) => getActiveElement(dom.getRootNode(ctx)),\n    isActiveElement: (ctx, elem) => elem === dom.getActiveElement(ctx),\n    getById: (ctx, id) => dom.getRootNode(ctx).getElementById(id),\n    setValue: (elem, value) => {\n      if (elem == null || value == null) return;\n      setElementValue(elem, value.toString());\n    }\n  };\n  return { ...dom, ...methods };\n}\n\n// src/searchable.ts\nvar sanitize = (str) => str.split(\"\").map((char) => {\n  const code = char.charCodeAt(0);\n  if (code > 0 && code < 128) return char;\n  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace(\"/\", \"\\\\\");\n  return \"\";\n}).join(\"\").trim();\nvar getValueText = (el) => {\n  return sanitize(el.dataset?.valuetext ?? el.textContent ?? \"\");\n};\nvar match = (valueText, query2) => {\n  return valueText.trim().toLowerCase().startsWith(query2.toLowerCase());\n};\nfunction getByText(v, text, currentId, itemToId = defaultItemToId) {\n  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;\n  let items = currentId ? wrap(v, index) : v;\n  const isSingleKey = text.length === 1;\n  if (isSingleKey) {\n    items = items.filter((item) => itemToId(item) !== currentId);\n  }\n  return items.find((item) => match(getValueText(item), text));\n}\n\n// src/set.ts\nfunction setAttribute(el, attr, v) {\n  const prev = el.getAttribute(attr);\n  const exists = prev != null;\n  el.setAttribute(attr, v);\n  return () => {\n    if (!exists) {\n      el.removeAttribute(attr);\n    } else {\n      el.setAttribute(attr, prev);\n    }\n  };\n}\nfunction setProperty(el, prop, v) {\n  const exists = prop in el;\n  const prev = el[prop];\n  el[prop] = v;\n  return () => {\n    if (!exists) {\n      delete el[prop];\n    } else {\n      el[prop] = prev;\n    }\n  };\n}\nfunction setStyle(el, style) {\n  if (!el) return noop;\n  const prev = Object.keys(style).reduce((acc, key) => {\n    acc[key] = el.style.getPropertyValue(key);\n    return acc;\n  }, {});\n  Object.assign(el.style, style);\n  return () => {\n    Object.assign(el.style, prev);\n    if (el.style.length === 0) {\n      el.removeAttribute(\"style\");\n    }\n  };\n}\nfunction setStyleProperty(el, prop, value) {\n  if (!el) return noop;\n  const prev = el.style.getPropertyValue(prop);\n  el.style.setProperty(prop, value);\n  return () => {\n    el.style.setProperty(prop, prev);\n    if (el.style.length === 0) {\n      el.removeAttribute(\"style\");\n    }\n  };\n}\n\n// src/typeahead.ts\nfunction getByTypeaheadImpl(baseItems, options) {\n  const { state: state2, activeId, key, timeout = 350, itemToId } = options;\n  const search = state2.keysSoFar + key;\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const query2 = isRepeated ? search[0] : search;\n  let items = baseItems.slice();\n  const next = getByText(items, query2, activeId, itemToId);\n  function cleanup() {\n    clearTimeout(state2.timer);\n    state2.timer = -1;\n  }\n  function update(value) {\n    state2.keysSoFar = value;\n    cleanup();\n    if (value !== \"\") {\n      state2.timer = +setTimeout(() => {\n        update(\"\");\n        cleanup();\n      }, timeout);\n    }\n  }\n  update(search);\n  return next;\n}\nvar getByTypeahead = /* @__PURE__ */ Object.assign(getByTypeaheadImpl, {\n  defaultOptions: { keysSoFar: \"\", timer: -1 },\n  isValidEvent: isValidTypeaheadEvent\n});\nfunction isValidTypeaheadEvent(event) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;\n}\n\n// src/visual-viewport.ts\nfunction trackVisualViewport(doc, fn) {\n  const win = doc?.defaultView || window;\n  const onResize = () => {\n    fn?.(getViewportSize(win));\n  };\n  onResize();\n  return addDomEvent(win.visualViewport ?? win, \"resize\", onResize);\n}\nfunction getViewportSize(win) {\n  return {\n    width: win.visualViewport?.width || win.innerWidth,\n    height: win.visualViewport?.height || win.innerHeight\n  };\n}\n\n// src/visually-hidden.ts\nvar visuallyHiddenStyle = {\n  border: \"0\",\n  clip: \"rect(0 0 0 0)\",\n  height: \"1px\",\n  margin: \"-1px\",\n  overflow: \"hidden\",\n  padding: \"0\",\n  position: \"absolute\",\n  width: \"1px\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\"\n};\nfunction setVisuallyHidden(el) {\n  Object.assign(el.style, visuallyHiddenStyle);\n}\n\n// src/wait-for.ts\nvar fps = 1e3 / 60;\nfunction waitForElement(query2, cb) {\n  const el = query2();\n  if (isHTMLElement(el) && el.isConnected) {\n    cb(el);\n    return () => void 0;\n  } else {\n    const timerId = setInterval(() => {\n      const el2 = query2();\n      if (isHTMLElement(el2) && el2.isConnected) {\n        cb(el2);\n        clearInterval(timerId);\n      }\n    }, fps);\n    return () => clearInterval(timerId);\n  }\n}\nfunction waitForElements(queries, cb) {\n  const cleanups = [];\n  queries?.forEach((query2) => {\n    const clean = waitForElement(query2, cb);\n    cleanups.push(clean);\n  });\n  return () => {\n    cleanups.forEach((fn) => fn());\n  };\n}\n\nexport { MAX_Z_INDEX, addDomEvent, ariaAttr, clickIfLink, contains, createScope, dataAttr, defaultItemToId, disableTextSelection, dispatchInputCheckedEvent, dispatchInputValueEvent, getActiveElement, getBeforeInputValue, getByText, getByTypeahead, getComputedStyle, getDataUrl, getDocument, getDocumentElement, getEventKey, getEventPoint, getEventStep, getEventTarget, getFirstFocusable, getFirstTabbable, getFocusables, getInitialFocus, getLastTabbable, getNativeEvent, getNearestOverflowAncestor, getNextTabbable, getNodeName, getOverflowAncestors, getParentNode, getPlatform, getRelativePoint, getScrollPosition, getTabIndex, getTabbableEdges, getTabbables, getUserAgent, getWindow, indexOfId, isAnchorElement, isAndroid, isApple, isCaretAtStart, isChrome, isComposingEvent, isContextMenuEvent, isCtrlOrMetaKey, isDocument, isDom, isDownloadingEvent, isEditableElement, isElementVisible, isFirefox, isFocusable, isHTMLElement, isIPad, isIPhone, isInView, isInputElement, isIos, isKeyboardClick, isLeftClick, isMac, isModifierKey, isNode, isOpeningInNewTab, isOverflowElement, isPrintableKey, isRootElement, isSafari, isSelfTarget, isShadowRoot, isTabbable, isTouchDevice, isTouchEvent, isValidTabEvent, isVirtualClick, isVirtualPointerEvent, isVisualViewport, isWebKit, isWindow, itemById, nextById, nextTick, observeAttributes, observeChildren, prevById, proxyTabFocus, query, queryAll, queueBeforeEvent, raf, requestPointerLock, restoreTextSelection, scrollIntoView, setAttribute, setCaretToEnd, setElementChecked, setElementValue, setProperty, setStyle, setStyleProperty, setVisuallyHidden, trackElementRect, trackFormControl, trackPointerMove, trackPress, trackVisualViewport, visuallyHiddenStyle, waitForElement, waitForElements };\n", "import { setStyleProperty, setStyle, isIos } from '@zag-js/dom-query';\n\n// src/index.ts\nvar LOCK_CLASSNAME = \"data-scroll-lock\";\nfunction getPaddingProperty(documentElement) {\n  const documentLeft = documentElement.getBoundingClientRect().left;\n  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;\n  return scrollbarX ? \"paddingLeft\" : \"paddingRight\";\n}\nfunction preventBodyScroll(_document) {\n  const doc = _document ?? document;\n  const win = doc.defaultView ?? window;\n  const { documentElement, body } = doc;\n  const locked = body.hasAttribute(LOCK_CLASSNAME);\n  if (locked) return;\n  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;\n  body.setAttribute(LOCK_CLASSNAME, \"\");\n  const setScrollbarWidthProperty = () => setStyleProperty(documentElement, \"--scrollbar-width\", `${scrollbarWidth}px`);\n  const paddingProperty = getPaddingProperty(documentElement);\n  const setBodyStyle = () => setStyle(body, {\n    overflow: \"hidden\",\n    [paddingProperty]: `${scrollbarWidth}px`\n  });\n  const setBodyStyleIOS = () => {\n    const { scrollX, scrollY, visualViewport } = win;\n    const offsetLeft = visualViewport?.offsetLeft ?? 0;\n    const offsetTop = visualViewport?.offsetTop ?? 0;\n    const restoreStyle = setStyle(body, {\n      position: \"fixed\",\n      overflow: \"hidden\",\n      top: `${-(scrollY - Math.floor(offsetTop))}px`,\n      left: `${-(scrollX - Math.floor(offsetLeft))}px`,\n      right: \"0\",\n      [paddingProperty]: `${scrollbarWidth}px`\n    });\n    return () => {\n      restoreStyle?.();\n      win.scrollTo({ left: scrollX, top: scrollY, behavior: \"instant\" });\n    };\n  };\n  const cleanups = [setScrollbarWidthProperty(), isIos() ? setBodyStyleIOS() : setBodyStyle()];\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n    body.removeAttribute(LOCK_CLASSNAME);\n  };\n}\n\nexport { preventBodyScroll };\n", "export const SELECTORS = {\r\n  dialogWrapper: \"[data-dialog-id]\",\r\n  close: \"[data-dialog-close]\",\r\n  backdrop: \"[data-dialog-backdrop]\",\r\n  title: \"[data-dialog-title]\",\r\n  desc: \"[data-dialog-desc]\",\r\n} as const;\r\n\r\nexport const PROPERTIES = {\r\n  dialogId: \"data-dialog-id\",\r\n  animation: \"data-dialog-animation\",\r\n} as const;\r\n\r\nexport const ANIMATION_TYPES = [\r\n  \"slide-from-top\",\r\n  \"slide-from-bottom\",\r\n  \"fade-in\",\r\n  \"scale-out\",\r\n  \"scale-in\",\r\n] as const;\r\n\r\nexport type AnimationType = (typeof ANIMATION_TYPES)[number];\r\n", "// src/array.ts\nfunction toArray(v) {\n  if (v == null) return [];\n  return Array.isArray(v) ? v : [v];\n}\nvar fromLength = (length) => Array.from(Array(length).keys());\nvar first = (v) => v[0];\nvar last = (v) => v[v.length - 1];\nvar isEmpty = (v) => v.length === 0;\nvar has = (v, t) => v.indexOf(t) !== -1;\nvar add = (v, ...items) => v.concat(items);\nvar remove = (v, ...items) => v.filter((t) => !items.includes(t));\nvar removeAt = (v, i) => v.filter((_, idx) => idx !== i);\nvar insertAt = (v, i, ...items) => [...v.slice(0, i), ...items, ...v.slice(i)];\nvar uniq = (v) => Array.from(new Set(v));\nvar diff = (a, b) => {\n  const set = new Set(b);\n  return a.filter((t) => !set.has(t));\n};\nvar addOrRemove = (v, item) => {\n  if (has(v, item)) return remove(v, item);\n  return add(v, item);\n};\nfunction clear(v) {\n  while (v.length > 0) v.pop();\n  return v;\n}\nfunction nextIndex(v, idx, opts = {}) {\n  const { step = 1, loop = true } = opts;\n  const next2 = idx + step;\n  const len = v.length;\n  const last2 = len - 1;\n  if (idx === -1) return step > 0 ? 0 : last2;\n  if (next2 < 0) return loop ? last2 : 0;\n  if (next2 >= len) return loop ? 0 : idx > len ? len : idx;\n  return next2;\n}\nfunction next(v, idx, opts = {}) {\n  return v[nextIndex(v, idx, opts)];\n}\nfunction prevIndex(v, idx, opts = {}) {\n  const { step = 1, loop = true } = opts;\n  return nextIndex(v, idx, { step: -step, loop });\n}\nfunction prev(v, index, opts = {}) {\n  return v[prevIndex(v, index, opts)];\n}\nvar chunk = (v, size) => {\n  const res = [];\n  return v.reduce((rows, value, index) => {\n    if (index % size === 0) rows.push([value]);\n    else last(rows)?.push(value);\n    return rows;\n  }, res);\n};\nfunction flatArray(arr) {\n  return arr.reduce((flat, item) => {\n    if (Array.isArray(item)) {\n      return flat.concat(flatArray(item));\n    }\n    return flat.concat(item);\n  }, []);\n}\n\n// src/equal.ts\nvar isArrayLike = (value) => value?.constructor.name === \"Array\";\nvar isArrayEqual = (a, b) => {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    if (!isEqual(a[i], b[i])) return false;\n  }\n  return true;\n};\nvar isEqual = (a, b) => {\n  if (Object.is(a, b)) return true;\n  if (a == null && b != null || a != null && b == null) return false;\n  if (typeof a?.isEqual === \"function\" && typeof b?.isEqual === \"function\") {\n    return a.isEqual(b);\n  }\n  if (typeof a === \"function\" && typeof b === \"function\") {\n    return a.toString() === b.toString();\n  }\n  if (isArrayLike(a) && isArrayLike(b)) {\n    return isArrayEqual(Array.from(a), Array.from(b));\n  }\n  if (!(typeof a === \"object\") || !(typeof b === \"object\")) return false;\n  const keys = Object.keys(b ?? /* @__PURE__ */ Object.create(null));\n  const length = keys.length;\n  for (let i = 0; i < length; i++) {\n    const hasKey = Reflect.has(a, keys[i]);\n    if (!hasKey) return false;\n  }\n  for (let i = 0; i < length; i++) {\n    const key = keys[i];\n    if (!isEqual(a[key], b[key])) return false;\n  }\n  return true;\n};\n\n// src/guard.ts\nvar isDev = () => process.env.NODE_ENV !== \"production\";\nvar isArray = (v) => Array.isArray(v);\nvar isBoolean = (v) => v === true || v === false;\nvar isObjectLike = (v) => v != null && typeof v === \"object\";\nvar isObject = (v) => isObjectLike(v) && !isArray(v);\nvar isNumber = (v) => typeof v === \"number\" && !Number.isNaN(v);\nvar isString = (v) => typeof v === \"string\";\nvar isFunction = (v) => typeof v === \"function\";\nvar isNull = (v) => v == null;\nvar hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nvar baseGetTag = (v) => Object.prototype.toString.call(v);\nvar fnToString = Function.prototype.toString;\nvar objectCtorString = fnToString.call(Object);\nvar isPlainObject = (v) => {\n  if (!isObjectLike(v) || baseGetTag(v) != \"[object Object]\") return false;\n  const proto = Object.getPrototypeOf(v);\n  if (proto === null) return true;\n  const Ctor = hasProp(proto, \"constructor\") && proto.constructor;\n  return typeof Ctor == \"function\" && Ctor instanceof Ctor && fnToString.call(Ctor) == objectCtorString;\n};\n\n// src/functions.ts\nvar runIfFn = (v, ...a) => {\n  const res = typeof v === \"function\" ? v(...a) : v;\n  return res ?? void 0;\n};\nvar cast = (v) => v;\nvar identity = (v) => v();\nvar noop = () => {\n};\nvar callAll = (...fns) => (...a) => {\n  fns.forEach(function(fn) {\n    fn?.(...a);\n  });\n};\nvar uuid = /* @__PURE__ */ (() => {\n  let id = 0;\n  return () => {\n    id++;\n    return id.toString(36);\n  };\n})();\nfunction match(key, record, ...args) {\n  if (key in record) {\n    const fn = record[key];\n    return isFunction(fn) ? fn(...args) : fn;\n  }\n  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`);\n  Error.captureStackTrace?.(error, match);\n  throw error;\n}\nvar tryCatch = (fn, fallback) => {\n  try {\n    return fn();\n  } catch (error) {\n    if (error instanceof Error) {\n      Error.captureStackTrace?.(error, tryCatch);\n    }\n    return fallback?.();\n  }\n};\nfunction throttle(fn, wait = 0) {\n  let lastCall = 0;\n  let timeout = null;\n  return (...args) => {\n    const now = Date.now();\n    const timeSinceLastCall = now - lastCall;\n    if (timeSinceLastCall >= wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      fn(...args);\n      lastCall = now;\n    } else if (!timeout) {\n      timeout = setTimeout(() => {\n        fn(...args);\n        lastCall = Date.now();\n        timeout = null;\n      }, wait - timeSinceLastCall);\n    }\n  };\n}\nfunction debounce(fn, wait = 0) {\n  let timeout = null;\n  return (...args) => {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n    timeout = setTimeout(() => {\n      fn(...args);\n    }, wait);\n  };\n}\n\n// src/number.ts\nvar { floor, abs, round, min, max, pow, sign } = Math;\nvar isNaN = (v) => Number.isNaN(v);\nvar nan = (v) => isNaN(v) ? 0 : v;\nvar mod = (v, m) => (v % m + m) % m;\nvar wrap = (v, vmax) => (v % vmax + vmax) % vmax;\nvar getMinValueAtIndex = (i, v, vmin) => i === 0 ? vmin : v[i - 1];\nvar getMaxValueAtIndex = (i, v, vmax) => i === v.length - 1 ? vmax : v[i + 1];\nvar isValueAtMax = (v, vmax) => nan(v) >= vmax;\nvar isValueAtMin = (v, vmin) => nan(v) <= vmin;\nvar isValueWithinRange = (v, vmin, vmax) => nan(v) >= vmin && nan(v) <= vmax;\nvar roundValue = (v, vmin, step) => round((nan(v) - vmin) / step) * step + vmin;\nvar clampValue = (v, vmin, vmax) => min(max(nan(v), vmin), vmax);\nvar clampPercent = (v) => clampValue(v, 0, 1);\nvar getValuePercent = (v, vmin, vmax) => (nan(v) - vmin) / (vmax - vmin);\nvar getPercentValue = (p, vmin, vmax, step) => clampValue(roundValue(p * (vmax - vmin) + vmin, vmin, step), vmin, vmax);\nvar roundToStepPrecision = (v, step) => {\n  let rv = v;\n  let ss = step.toString();\n  let pi = ss.indexOf(\".\");\n  let p = pi >= 0 ? ss.length - pi : 0;\n  if (p > 0) {\n    let pw = pow(10, p);\n    rv = round(rv * pw) / pw;\n  }\n  return rv;\n};\nvar roundToDpr = (v, dpr) => typeof dpr === \"number\" ? floor(v * dpr + 0.5) / dpr : round(v);\nvar snapValueToStep = (v, vmin, vmax, step) => {\n  const min2 = vmin != null ? Number(vmin) : 0;\n  const max2 = Number(vmax);\n  const remainder = (v - min2) % step;\n  let snapped = abs(remainder) * 2 >= step ? v + sign(remainder) * (step - abs(remainder)) : v - remainder;\n  snapped = roundToStepPrecision(snapped, step);\n  if (!isNaN(min2) && snapped < min2) {\n    snapped = min2;\n  } else if (!isNaN(max2) && snapped > max2) {\n    const stepsInRange = floor((max2 - min2) / step);\n    const largestValidStep = min2 + stepsInRange * step;\n    snapped = stepsInRange <= 0 || largestValidStep < min2 ? max2 : largestValidStep;\n  }\n  return roundToStepPrecision(snapped, step);\n};\nvar setValueAtIndex = (vs, i, v) => {\n  if (vs[i] === v) return vs;\n  return [...vs.slice(0, i), v, ...vs.slice(i + 1)];\n};\nfunction getValueSetterAtIndex(index, ctx) {\n  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);\n  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);\n  let nextValues = ctx.values.slice();\n  return function setValue(value) {\n    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);\n    nextValues = setValueAtIndex(nextValues, index, value);\n    nextValues[index] = nextValue;\n    return nextValues;\n  };\n}\nfunction getNextStepValue(index, ctx) {\n  const nextValue = ctx.values[index] + ctx.step;\n  return getValueSetterAtIndex(index, ctx)(nextValue);\n}\nfunction getPreviousStepValue(index, ctx) {\n  const nextValue = ctx.values[index] - ctx.step;\n  return getValueSetterAtIndex(index, ctx)(nextValue);\n}\nvar getClosestValueIndex = (vs, t) => {\n  let i = vs.findIndex((v) => t - v < 0);\n  if (i === 0) return i;\n  if (i === -1) return vs.length - 1;\n  let vLeft = vs[i - 1];\n  let vRight = vs[i];\n  if (abs(vLeft - t) < abs(vRight - t)) return i - 1;\n  return i;\n};\nvar getClosestValue = (vs, t) => vs[getClosestValueIndex(vs, t)];\nvar getValueRanges = (vs, vmin, vmax, gap) => vs.map((v, i) => ({\n  min: i === 0 ? vmin : vs[i - 1] + gap,\n  max: i === vs.length - 1 ? vmax : vs[i + 1] - gap,\n  value: v\n}));\nvar getValueTransformer = (va, vb) => {\n  const [a, b] = va;\n  const [c, d] = vb;\n  return (v) => a === b || c === d ? c : c + (d - c) / (b - a) * (v - a);\n};\nvar toFixedNumber = (v, d = 0, b = 10) => {\n  const pow2 = Math.pow(b, d);\n  return round(v * pow2) / pow2;\n};\nvar countDecimals = (value) => {\n  if (!Number.isFinite(value)) return 0;\n  let e = 1, p = 0;\n  while (Math.round(value * e) / e !== value) {\n    e *= 10;\n    p += 1;\n  }\n  return p;\n};\nvar decimalOp = (a, op, b) => {\n  let result = op === \"+\" ? a + b : a - b;\n  if (a % 1 !== 0 || b % 1 !== 0) {\n    const multiplier = 10 ** Math.max(countDecimals(a), countDecimals(b));\n    a = Math.round(a * multiplier);\n    b = Math.round(b * multiplier);\n    result = op === \"+\" ? a + b : a - b;\n    result /= multiplier;\n  }\n  return result;\n};\nvar incrementValue = (v, s) => decimalOp(nan(v), \"+\", s);\nvar decrementValue = (v, s) => decimalOp(nan(v), \"-\", s);\nvar toPx = (v) => v != null ? `${v}px` : void 0;\n\n// src/object.ts\nfunction compact(obj) {\n  if (!isPlainObject2(obj) || obj === void 0) return obj;\n  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === \"string\");\n  const filtered = {};\n  for (const key of keys) {\n    const value = obj[key];\n    if (value !== void 0) {\n      filtered[key] = compact(value);\n    }\n  }\n  return filtered;\n}\nvar json = (v) => JSON.parse(JSON.stringify(v));\nvar isPlainObject2 = (v) => {\n  return v && typeof v === \"object\" && v.constructor === Object;\n};\nfunction pick(obj, keys) {\n  const filtered = {};\n  for (const key of keys) {\n    const value = obj[key];\n    if (value !== void 0) {\n      filtered[key] = value;\n    }\n  }\n  return filtered;\n}\nfunction splitProps(props, keys) {\n  const rest = {};\n  const result = {};\n  const keySet = new Set(keys);\n  for (const key in props) {\n    if (keySet.has(key)) {\n      result[key] = props[key];\n    } else {\n      rest[key] = props[key];\n    }\n  }\n  return [result, rest];\n}\nvar createSplitProps = (keys) => {\n  return function split(props) {\n    return splitProps(props, keys);\n  };\n};\nfunction omit(obj, keys) {\n  return createSplitProps(keys)(obj)[1];\n}\n\n// src/timers.ts\nfunction setRafInterval(callback, interval) {\n  let start = performance.now();\n  let handle;\n  function loop(now) {\n    handle = requestAnimationFrame(loop);\n    const delta = now - start;\n    if (delta >= interval) {\n      start = now - delta % interval;\n      callback({ startMs: start, deltaMs: delta });\n    }\n  }\n  handle = requestAnimationFrame(loop);\n  return () => cancelAnimationFrame(handle);\n}\nfunction setRafTimeout(callback, delay) {\n  const start = performance.now();\n  let handle;\n  function loop(now) {\n    handle = requestAnimationFrame(loop);\n    const delta = now - start;\n    if (delta >= delay) {\n      callback();\n    }\n  }\n  handle = requestAnimationFrame(loop);\n  return () => cancelAnimationFrame(handle);\n}\n\n// src/warning.ts\nfunction warn(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && process.env.NODE_ENV !== \"production\") {\n    console.warn(m);\n  }\n}\nfunction invariant(...a) {\n  const m = a.length === 1 ? a[0] : a[1];\n  const c = a.length === 2 ? a[0] : true;\n  if (c && process.env.NODE_ENV !== \"production\") {\n    throw new Error(m);\n  }\n}\nfunction ensure(c, m) {\n  if (c == null) throw new Error(m());\n}\nfunction ensureProps(props, keys, scope) {\n  let missingKeys = [];\n  for (const key of keys) {\n    if (props[key] == null) missingKeys.push(key);\n  }\n  if (missingKeys.length > 0)\n    throw new Error(`[zag-js${scope ? ` > ${scope}` : \"\"}] missing required props: ${missingKeys.join(\", \")}`);\n}\n\nexport { add, addOrRemove, callAll, cast, chunk, clampPercent, clampValue, clear, compact, createSplitProps, debounce, decrementValue, diff, ensure, ensureProps, first, flatArray, fromLength, getClosestValue, getClosestValueIndex, getMaxValueAtIndex, getMinValueAtIndex, getNextStepValue, getPercentValue, getPreviousStepValue, getValuePercent, getValueRanges, getValueSetterAtIndex, getValueTransformer, has, hasProp, identity, incrementValue, insertAt, invariant, isArray, isBoolean, isDev, isEmpty, isEqual, isFunction, isNaN, isNull, isNumber, isObject, isObjectLike, isPlainObject, isString, isValueAtMax, isValueAtMin, isValueWithinRange, json, last, match, mod, nan, next, nextIndex, noop, omit, pick, prev, prevIndex, remove, removeAt, roundToDpr, roundToStepPrecision, roundValue, runIfFn, setRafInterval, setRafTimeout, setValueAtIndex, snapValueToStep, splitProps, throttle, toArray, toFixedNumber, toPx, tryCatch, uniq, uuid, warn, wrap };\n", "import { raf, getDocument, getWindow, isShadowRoot, addDomEvent, isTouchDevice, getEventTarget, isFocusable, isContextMenuEvent, isHTMLElement, contains, getNearestOverflowAncestor } from '@zag-js/dom-query';\nimport { callAll } from '@zag-js/utils';\n\n// src/index.ts\n\n// src/frame-utils.ts\nfunction getWindowFrames(win) {\n  const frames = {\n    each(cb) {\n      for (let i = 0; i < win.frames?.length; i += 1) {\n        const frame = win.frames[i];\n        if (frame) cb(frame);\n      }\n    },\n    addEventListener(event, listener, options) {\n      frames.each((frame) => {\n        try {\n          frame.document.addEventListener(event, listener, options);\n        } catch {\n        }\n      });\n      return () => {\n        try {\n          frames.removeEventListener(event, listener, options);\n        } catch {\n        }\n      };\n    },\n    removeEventListener(event, listener, options) {\n      frames.each((frame) => {\n        try {\n          frame.document.removeEventListener(event, listener, options);\n        } catch {\n        }\n      });\n    }\n  };\n  return frames;\n}\nfunction getParentWindow(win) {\n  const parent = win.frameElement != null ? win.parent : null;\n  return {\n    addEventListener: (event, listener, options) => {\n      try {\n        parent?.addEventListener(event, listener, options);\n      } catch {\n      }\n      return () => {\n        try {\n          parent?.removeEventListener(event, listener, options);\n        } catch {\n        }\n      };\n    },\n    removeEventListener: (event, listener, options) => {\n      try {\n        parent?.removeEventListener(event, listener, options);\n      } catch {\n      }\n    }\n  };\n}\n\n// src/index.ts\nvar POINTER_OUTSIDE_EVENT = \"pointerdown.outside\";\nvar FOCUS_OUTSIDE_EVENT = \"focus.outside\";\nfunction isComposedPathFocusable(composedPath) {\n  for (const node of composedPath) {\n    if (isHTMLElement(node) && isFocusable(node)) return true;\n  }\n  return false;\n}\nvar isPointerEvent = (event) => \"clientY\" in event;\nfunction isEventPointWithin(node, event) {\n  if (!isPointerEvent(event) || !node) return false;\n  const rect = node.getBoundingClientRect();\n  if (rect.width === 0 || rect.height === 0) return false;\n  return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;\n}\nfunction isPointInRect(rect, point) {\n  return rect.y <= point.y && point.y <= rect.y + rect.height && rect.x <= point.x && point.x <= rect.x + rect.width;\n}\nfunction isEventWithinScrollbar(event, ancestor) {\n  if (!ancestor || !isPointerEvent(event)) return false;\n  const isScrollableY = ancestor.scrollHeight > ancestor.clientHeight;\n  const onScrollbarY = isScrollableY && event.clientX > ancestor.offsetLeft + ancestor.clientWidth;\n  const isScrollableX = ancestor.scrollWidth > ancestor.clientWidth;\n  const onScrollbarX = isScrollableX && event.clientY > ancestor.offsetTop + ancestor.clientHeight;\n  const rect = {\n    x: ancestor.offsetLeft,\n    y: ancestor.offsetTop,\n    width: ancestor.clientWidth + (isScrollableY ? 16 : 0),\n    height: ancestor.clientHeight + (isScrollableX ? 16 : 0)\n  };\n  const point = {\n    x: event.clientX,\n    y: event.clientY\n  };\n  if (!isPointInRect(rect, point)) return false;\n  return onScrollbarY || onScrollbarX;\n}\nfunction trackInteractOutsideImpl(node, options) {\n  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options;\n  if (!node) return;\n  const doc = getDocument(node);\n  const win = getWindow(node);\n  const frames = getWindowFrames(win);\n  const parentWin = getParentWindow(win);\n  function isEventOutside(event, target) {\n    if (!isHTMLElement(target)) return false;\n    if (!target.isConnected) return false;\n    if (contains(node, target)) return false;\n    if (isEventPointWithin(node, event)) return false;\n    const triggerEl = doc.querySelector(`[aria-controls=\"${node.id}\"]`);\n    if (triggerEl) {\n      const triggerAncestor = getNearestOverflowAncestor(triggerEl);\n      if (isEventWithinScrollbar(event, triggerAncestor)) return false;\n    }\n    const nodeAncestor = getNearestOverflowAncestor(node);\n    if (isEventWithinScrollbar(event, nodeAncestor)) return false;\n    return !exclude?.(target);\n  }\n  const pointerdownCleanups = /* @__PURE__ */ new Set();\n  const isInShadowRoot = isShadowRoot(node?.getRootNode());\n  function onPointerDown(event) {\n    function handler(clickEvent) {\n      const func = defer && !isTouchDevice() ? raf : (v) => v();\n      const evt = clickEvent ?? event;\n      const composedPath = evt?.composedPath?.() ?? [evt?.target];\n      func(() => {\n        const target = isInShadowRoot ? composedPath[0] : getEventTarget(event);\n        if (!node || !isEventOutside(event, target)) return;\n        if (onPointerDownOutside || onInteractOutside) {\n          const handler2 = callAll(onPointerDownOutside, onInteractOutside);\n          node.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });\n        }\n        fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {\n          bubbles: false,\n          cancelable: true,\n          detail: {\n            originalEvent: evt,\n            contextmenu: isContextMenuEvent(evt),\n            focusable: isComposedPathFocusable(composedPath),\n            target\n          }\n        });\n      });\n    }\n    if (event.pointerType === \"touch\") {\n      pointerdownCleanups.forEach((fn) => fn());\n      pointerdownCleanups.add(addDomEvent(doc, \"click\", handler, { once: true }));\n      pointerdownCleanups.add(parentWin.addEventListener(\"click\", handler, { once: true }));\n      pointerdownCleanups.add(frames.addEventListener(\"click\", handler, { once: true }));\n    } else {\n      handler();\n    }\n  }\n  const cleanups = /* @__PURE__ */ new Set();\n  const timer = setTimeout(() => {\n    cleanups.add(addDomEvent(doc, \"pointerdown\", onPointerDown, true));\n    cleanups.add(parentWin.addEventListener(\"pointerdown\", onPointerDown, true));\n    cleanups.add(frames.addEventListener(\"pointerdown\", onPointerDown, true));\n  }, 0);\n  function onFocusin(event) {\n    const func = defer ? raf : (v) => v();\n    func(() => {\n      const target = getEventTarget(event);\n      if (!node || !isEventOutside(event, target)) return;\n      if (onFocusOutside || onInteractOutside) {\n        const handler = callAll(onFocusOutside, onInteractOutside);\n        node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });\n      }\n      fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {\n        bubbles: false,\n        cancelable: true,\n        detail: {\n          originalEvent: event,\n          contextmenu: false,\n          focusable: isFocusable(target),\n          target\n        }\n      });\n    });\n  }\n  if (!isTouchDevice()) {\n    cleanups.add(addDomEvent(doc, \"focusin\", onFocusin, true));\n    cleanups.add(parentWin.addEventListener(\"focusin\", onFocusin, true));\n    cleanups.add(frames.addEventListener(\"focusin\", onFocusin, true));\n  }\n  return () => {\n    clearTimeout(timer);\n    pointerdownCleanups.forEach((fn) => fn());\n    cleanups.forEach((fn) => fn());\n  };\n}\nfunction trackInteractOutside(nodeOrFn, options) {\n  const { defer } = options;\n  const func = defer ? raf : (v) => v();\n  const cleanups = [];\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n      cleanups.push(trackInteractOutsideImpl(node, options));\n    })\n  );\n  return () => {\n    cleanups.forEach((fn) => fn?.());\n  };\n}\nfunction fireCustomEvent(el, type, init) {\n  const win = el.ownerDocument.defaultView || window;\n  const event = new win.CustomEvent(type, init);\n  return el.dispatchEvent(event);\n}\n\nexport { trackInteractOutside };\n", "import type { GSAPTweenVars } from \"@taj-wf/utils\";\r\n\r\nconst commonOpenAnimationProps: GSAPTweenVars = { duration: 0.4, ease: \"back.out\" };\r\nconst commonCloseAnimationProps: GSAPTweenVars = { duration: 0.4, ease: \"back.in\" };\r\n\r\nexport type DialogAnimation = (dialogChildrens: HTMLElement[]) => GSAPTween;\r\n\r\nexport const openAnimations = {\r\n  scaleOut: (dialogChildrens: HTMLElement[]) => {\r\n    return gsap.fromTo(\r\n      dialogChildrens,\r\n      {\r\n        scale: 0.8,\r\n        opacity: 0,\r\n      },\r\n      { scale: 1, opacity: 1, ...commonOpenAnimationProps }\r\n    );\r\n  },\r\n  scaleIn: (dialogChildrens: HTMLElement[]) => {\r\n    return gsap.fromTo(\r\n      dialogChildrens,\r\n      {\r\n        scale: 1.2,\r\n        opacity: 0,\r\n      },\r\n      { scale: 1, opacity: 1, ...commonOpenAnimationProps }\r\n    );\r\n  },\r\n  fadeIn: (dialogChildrens: HTMLElement[]) => {\r\n    return gsap.fromTo(\r\n      dialogChildrens,\r\n      {\r\n        opacity: 0,\r\n      },\r\n      { opacity: 1, ...commonOpenAnimationProps, ease: \"power2.inOut\" }\r\n    );\r\n  },\r\n  slideFromBottom: (dialogChildrens: HTMLElement[]) => {\r\n    return gsap.fromTo(\r\n      dialogChildrens,\r\n      {\r\n        y: \"20%\",\r\n        opacity: 0,\r\n      },\r\n      { y: 0, opacity: 1, ...commonOpenAnimationProps }\r\n    );\r\n  },\r\n  slideFromTop: (dialogChildrens: HTMLElement[]) => {\r\n    return gsap.fromTo(\r\n      dialogChildrens,\r\n      {\r\n        y: \"-20%\",\r\n        opacity: 0,\r\n      },\r\n      { y: 0, opacity: 1, ...commonOpenAnimationProps }\r\n    );\r\n  },\r\n} as const;\r\n\r\nexport const closeAnimations = {\r\n  scaleOut: (dialogChildrens: HTMLElement[]) => {\r\n    return gsap.to(dialogChildrens, {\r\n      scale: 1.2,\r\n      opacity: 0,\r\n      duration: 0.4,\r\n      ...commonCloseAnimationProps,\r\n    });\r\n  },\r\n  scaleIn: (dialogChildrens: HTMLElement[]) => {\r\n    return gsap.to(dialogChildrens, {\r\n      scale: 0.8,\r\n      opacity: 0,\r\n      duration: 0.4,\r\n      ...commonCloseAnimationProps,\r\n    });\r\n  },\r\n  fadeOut: (dialogChildrens: HTMLElement[]) => {\r\n    return gsap.to(dialogChildrens, {\r\n      opacity: 0,\r\n      duration: 0.4,\r\n      ...commonCloseAnimationProps,\r\n      ease: \"power2.inOut\",\r\n    });\r\n  },\r\n  slideToBottom: (dialogChildrens: HTMLElement[]) => {\r\n    return gsap.to(dialogChildrens, {\r\n      y: \"20%\",\r\n      opacity: 0,\r\n      duration: 0.4,\r\n      ...commonCloseAnimationProps,\r\n    });\r\n  },\r\n  slideToTop: (dialogChildrens: HTMLElement[]) => {\r\n    return gsap.to(dialogChildrens, {\r\n      y: \"-20%\",\r\n      opacity: 0,\r\n      duration: 0.4,\r\n      ...commonCloseAnimationProps,\r\n    });\r\n  },\r\n} as const;\r\n\r\nexport const backdropAnimations = {\r\n  open: (backdropEl: HTMLElement) => {\r\n    return gsap.from(backdropEl, {\r\n      opacity: 0,\r\n      duration: 0.4,\r\n    });\r\n  },\r\n  close: (backdropEl: HTMLElement) => {\r\n    return gsap.to(backdropEl, {\r\n      opacity: 1,\r\n      duration: 0.4,\r\n    });\r\n  },\r\n};\r\n", "import { getHtmlElement, getMultipleHtmlElements } from \"@taj-wf/utils\";\r\nimport { trackInteractOutside } from \"@zag-js/interact-outside\";\r\n\r\nimport {\r\n  backdropAnimations,\r\n  closeAnimations,\r\n  type DialogAnimation,\r\n  openAnimations,\r\n} from \"./animations\";\r\nimport { ANIMATION_TYPES, type AnimationType, PROPERTIES, SELECTORS } from \"./constants\";\r\n\r\n/** Utility: generate a random ID */\r\nfunction randomId(prefix = \"id\") {\r\n  return `${prefix}-${Math.random().toString(36).slice(2, 10)}`;\r\n}\r\n\r\n/** Utility: find all focusable descendants, excluding tabindex=\"-1\" elements */\r\nfunction getFocusable(el: HTMLElement): HTMLElement[] {\r\n  const focusableSelectors = [\r\n    'a[href]:not([tabindex=\"-1\"])',\r\n    'button:not([disabled]):not([tabindex=\"-1\"])',\r\n    'textarea:not([disabled]):not([tabindex=\"-1\"])',\r\n    'input:not([disabled]):not([tabindex=\"-1\"])',\r\n    'select:not([disabled]):not([tabindex=\"-1\"])',\r\n    '[tabindex]:not([tabindex=\"-1\"])',\r\n  ].join(\",\");\r\n\r\n  return Array.from(el.querySelectorAll<HTMLElement>(focusableSelectors)).filter(\r\n    (n) => n.offsetWidth || n.offsetHeight || n === document.activeElement\r\n  );\r\n}\r\n\r\n/** Assign unique IDs to dialog elements for accessibility */\r\nfunction assignElementIds(opts: {\r\n  dialogEl: HTMLElement;\r\n  triggers: HTMLElement[];\r\n  closers: HTMLElement[];\r\n  backdropEl: HTMLElement;\r\n  titleEl?: HTMLElement;\r\n  descriptionEl?: HTMLElement;\r\n  prefix: string;\r\n}) {\r\n  const { dialogEl, triggers, closers, backdropEl, titleEl, descriptionEl, prefix } = opts;\r\n\r\n  if (!dialogEl.id) dialogEl.id = prefix;\r\n\r\n  // assign id to single trigger only\r\n  if (triggers.length === 1) {\r\n    const btn = triggers[0]!;\r\n    if (!btn.id) btn.id = `${prefix}-Trigger`;\r\n  }\r\n\r\n  // assign id to single closer only\r\n  if (closers.length === 1) {\r\n    const btn = closers[0]!;\r\n    if (!btn.id) btn.id = `${prefix}-Close`;\r\n  }\r\n\r\n  backdropEl.id ||= `${prefix}-Backdrop`;\r\n  if (titleEl && !titleEl.id) titleEl.id = `${prefix}-Title`;\r\n  if (descriptionEl && !descriptionEl.id) descriptionEl.id = `${prefix}-Description`;\r\n}\r\n\r\n/** Setup ARIA attributes for accessibility */\r\nfunction setupAriaAttributes(opts: {\r\n  dialogEl: HTMLElement;\r\n  triggers: HTMLElement[];\r\n  titleEl?: HTMLElement;\r\n  descriptionEl?: HTMLElement;\r\n}) {\r\n  const { dialogEl, triggers, titleEl, descriptionEl } = opts;\r\n\r\n  // only apply aria to a single trigger\r\n  if (triggers.length === 1) {\r\n    const btn = triggers[0]!;\r\n    btn.setAttribute(\"aria-haspopup\", \"dialog\");\r\n    btn.setAttribute(\"aria-controls\", dialogEl.id);\r\n  }\r\n\r\n  dialogEl.setAttribute(\"role\", \"dialog\");\r\n  dialogEl.setAttribute(\"aria-modal\", \"true\");\r\n  dialogEl.setAttribute(\r\n    \"aria-labelledby\",\r\n    titleEl ? titleEl.id : triggers.length === 1 ? triggers[0]!.id : dialogEl.id\r\n  );\r\n\r\n  if (descriptionEl) {\r\n    dialogEl.setAttribute(\"aria-describedby\", descriptionEl.id);\r\n  }\r\n}\r\n\r\n/** Handle dialog open animation */\r\nfunction createOpenAnimation({\r\n  dialogEl,\r\n  backdropEl,\r\n  childrenElements,\r\n  animation,\r\n}: {\r\n  dialogEl: HTMLElement;\r\n  backdropEl: HTMLElement;\r\n  childrenElements: HTMLElement[];\r\n  animation: DialogAnimation | null;\r\n}) {\r\n  const isAnimationDisabled = dialogEl.hasAttribute(\"data-dialog-no-animation\");\r\n\r\n  return function openAnimation() {\r\n    if (dialogEl.classList.contains(\"is--hidden\")) {\r\n      dialogEl.classList.remove(\"is--hidden\");\r\n    }\r\n\r\n    if (animation && !isAnimationDisabled) {\r\n      dialogEl.style.removeProperty(\"display\");\r\n      backdropAnimations.open(backdropEl);\r\n      animation(childrenElements);\r\n      return;\r\n    }\r\n\r\n    dialogEl.style.removeProperty(\"display\");\r\n  };\r\n}\r\n\r\n/** Handle dialog close animation */\r\nfunction createCloseAnimation({\r\n  dialogEl,\r\n  backdropEl,\r\n  childrenElements,\r\n  animation,\r\n  onComplete,\r\n}: {\r\n  dialogEl: HTMLElement;\r\n  backdropEl: HTMLElement;\r\n  childrenElements: HTMLElement[];\r\n  animation: DialogAnimation | null;\r\n  onComplete?: () => void;\r\n}) {\r\n  const isAnimationDisabled = dialogEl.hasAttribute(\"data-dialog-no-animation\");\r\n\r\n  return function closeAnimation() {\r\n    if (animation && !isAnimationDisabled) {\r\n      backdropAnimations.close(backdropEl);\r\n      animation(childrenElements).then(() => {\r\n        dialogEl.style.display = \"none\";\r\n        onComplete?.();\r\n      });\r\n      return;\r\n    }\r\n\r\n    dialogEl.style.display = \"none\";\r\n    onComplete?.();\r\n  };\r\n}\r\n\r\n/** Handle auto-focus logic when dialog opens */\r\nfunction handleAutoFocus(dialogEl: HTMLElement, autoFocusInputEl?: HTMLInputElement | \"disable\") {\r\n  if (autoFocusInputEl === \"disable\") return;\r\n\r\n  const target =\r\n    autoFocusInputEl instanceof HTMLInputElement\r\n      ? autoFocusInputEl\r\n      : (dialogEl.querySelector(\"input\") as HTMLInputElement | null);\r\n\r\n  target?.focus();\r\n}\r\n\r\n/** Handle focus trap cycling */\r\nfunction handleFocusTrap(e: KeyboardEvent, dialogEl: HTMLElement) {\r\n  const focusables = getFocusable(dialogEl);\r\n  const idx = focusables.indexOf(document.activeElement as HTMLElement);\r\n  const next = e.shiftKey\r\n    ? idx > 0\r\n      ? focusables[idx - 1]\r\n      : focusables[focusables.length - 1]\r\n    : idx < focusables.length - 1\r\n      ? focusables[idx + 1]\r\n      : focusables[0];\r\n\r\n  e.preventDefault();\r\n  next?.focus();\r\n}\r\n\r\n/** Create keyboard event handler for dialog */\r\nfunction createKeyboardHandler(\r\n  dialogEl: HTMLElement,\r\n  close: () => void,\r\n  isOpenRef: { current: boolean }\r\n) {\r\n  return function handleKeydown(e: KeyboardEvent) {\r\n    if (!isOpenRef.current) return;\r\n\r\n    if (e.key === \"Escape\") {\r\n      e.preventDefault();\r\n      close();\r\n    }\r\n\r\n    if (e.key === \"Tab\") {\r\n      handleFocusTrap(e, dialogEl);\r\n    }\r\n  };\r\n}\r\n\r\n/** Setup event listeners for triggers and closers */\r\nfunction setupEventListeners(opts: {\r\n  triggers: HTMLElement[];\r\n  closers: HTMLElement[];\r\n  backdropEl: HTMLElement;\r\n  dialogEl: HTMLElement;\r\n  open: () => void;\r\n  close: () => void;\r\n  keydownHandler: (e: KeyboardEvent) => void;\r\n}) {\r\n  const { triggers, closers, backdropEl, dialogEl, open, close, keydownHandler } = opts;\r\n\r\n  // Setup trigger listeners\r\n  triggers.forEach((el) => el.addEventListener(\"click\", open));\r\n\r\n  // Setup closer listeners\r\n  closers.forEach((el) => el.addEventListener(\"click\", close));\r\n  backdropEl.addEventListener(\"click\", close);\r\n\r\n  // Setup keyboard listener\r\n  dialogEl.addEventListener(\"keydown\", keydownHandler);\r\n\r\n  // Return cleanup function\r\n  return function cleanup() {\r\n    triggers.forEach((el) => el.removeEventListener(\"click\", open));\r\n    closers.forEach((el) => el.removeEventListener(\"click\", close));\r\n    backdropEl.removeEventListener(\"click\", close);\r\n    dialogEl.removeEventListener(\"keydown\", keydownHandler);\r\n  };\r\n}\r\n\r\n/** Remove ARIA attributes that were added during initialization */\r\nfunction removeAriaAttributes(opts: { dialogEl: HTMLElement; triggers: HTMLElement[] }) {\r\n  const { dialogEl, triggers } = opts;\r\n\r\n  // Remove aria from single trigger\r\n  if (triggers.length === 1) {\r\n    const btn = triggers[0]!;\r\n    btn.removeAttribute(\"aria-haspopup\");\r\n    btn.removeAttribute(\"aria-controls\");\r\n  }\r\n\r\n  dialogEl.removeAttribute(\"role\");\r\n  dialogEl.removeAttribute(\"aria-modal\");\r\n  dialogEl.removeAttribute(\"aria-labelledby\");\r\n  dialogEl.removeAttribute(\"aria-describedby\");\r\n}\r\n\r\nfunction getAnimations(animationType: string) {\r\n  let finalAnimationType: AnimationType = \"slide-from-bottom\";\r\n\r\n  // @ts-expect-error include animation type check\r\n  if (ANIMATION_TYPES.includes(animationType)) {\r\n    finalAnimationType = animationType as AnimationType;\r\n  }\r\n\r\n  if (finalAnimationType === \"slide-from-top\") {\r\n    return { open: openAnimations.slideFromTop, close: closeAnimations.slideToTop };\r\n  }\r\n\r\n  if (finalAnimationType === \"slide-from-bottom\") {\r\n    return { open: openAnimations.slideFromBottom, close: closeAnimations.slideToBottom };\r\n  }\r\n\r\n  if (finalAnimationType === \"fade-in\") {\r\n    return { open: openAnimations.fadeIn, close: closeAnimations.fadeOut };\r\n  }\r\n\r\n  if (finalAnimationType === \"scale-out\") {\r\n    return { open: openAnimations.scaleOut, close: closeAnimations.scaleIn };\r\n  }\r\n\r\n  if (finalAnimationType === \"scale-in\") {\r\n    return { open: openAnimations.scaleIn, close: closeAnimations.scaleOut };\r\n  }\r\n\r\n  return { open: openAnimations.slideFromBottom, close: closeAnimations.slideToBottom };\r\n}\r\n\r\ntype CreateDialogReturn = (DialogAPI & { destroy: () => void }) | null;\r\n\r\nexport function createDialog(opts: DialogOptions): CreateDialogReturn {\r\n  const {\r\n    dialogEl,\r\n    triggerEls,\r\n    closeEls,\r\n    disableScroll,\r\n    enableScroll,\r\n    onDialogOpen,\r\n    onDialogClose,\r\n    autoFocusInputEl,\r\n    descriptionEl,\r\n    titleEl,\r\n    isGsapAvailable,\r\n  } = opts;\r\n\r\n  const backdropEl = getHtmlElement({\r\n    selector: SELECTORS.backdrop,\r\n    parent: dialogEl,\r\n    log: \"error\",\r\n  });\r\n\r\n  if (!backdropEl) return null;\r\n\r\n  const dialogChildrenElementsBesidesBackdrop = getMultipleHtmlElements({\r\n    parent: dialogEl,\r\n    selector: `:scope > *:not(${SELECTORS.backdrop})`,\r\n    log: \"error\",\r\n  });\r\n\r\n  if (!dialogChildrenElementsBesidesBackdrop) return null;\r\n\r\n  const dialogAnimations = isGsapAvailable\r\n    ? getAnimations(dialogEl.getAttribute(PROPERTIES.animation) || \"\")\r\n    : null;\r\n\r\n  const defaultOpen = opts.isOpen ?? false;\r\n  const triggers = triggerEls;\r\n  const closers = closeEls;\r\n\r\n  // Generate unique prefix for this dialog instance\r\n  const prefix = randomId(\"Dialog\");\r\n\r\n  // Setup element IDs for accessibility\r\n  assignElementIds({\r\n    dialogEl,\r\n    triggers,\r\n    closers,\r\n    backdropEl,\r\n    titleEl,\r\n    descriptionEl,\r\n    prefix,\r\n  });\r\n\r\n  // Setup ARIA attributes\r\n  setupAriaAttributes({\r\n    dialogEl,\r\n    triggers,\r\n    titleEl,\r\n    descriptionEl,\r\n  });\r\n\r\n  // Create animation functions\r\n  const openAnimation = createOpenAnimation({\r\n    dialogEl,\r\n    backdropEl,\r\n    childrenElements: dialogChildrenElementsBesidesBackdrop,\r\n    animation: dialogAnimations?.open || null,\r\n  });\r\n  const closeAnimation = createCloseAnimation({\r\n    dialogEl,\r\n    backdropEl,\r\n    childrenElements: dialogChildrenElementsBesidesBackdrop,\r\n    animation: dialogAnimations?.close || null,\r\n    onComplete: () => {\r\n      enableScroll();\r\n    },\r\n  });\r\n\r\n  // State management\r\n  let isOpen = false;\r\n  let cleanupInteractOutside: (() => void) | null = null;\r\n  const isOpenRef = { current: false }; // Reference for keyboard handler\r\n\r\n  // Core dialog functions\r\n  function open() {\r\n    if (isOpen) return;\r\n\r\n    isOpen = true;\r\n    isOpenRef.current = true;\r\n    disableScroll();\r\n\r\n    openAnimation();\r\n\r\n    handleAutoFocus(dialogEl, autoFocusInputEl);\r\n\r\n    // Setup outside interaction tracking\r\n    cleanupInteractOutside = trackInteractOutside(dialogEl, {\r\n      onPointerDownOutside: close,\r\n      onInteractOutside: close,\r\n      onFocusOutside: close,\r\n    });\r\n\r\n    onDialogOpen?.();\r\n  }\r\n\r\n  function close() {\r\n    isOpen = false;\r\n    isOpenRef.current = false;\r\n    closeAnimation();\r\n    cleanupInteractOutside?.();\r\n    cleanupInteractOutside = null;\r\n    onDialogClose?.();\r\n  }\r\n\r\n  function toggle() {\r\n    if (isOpen) {\r\n      close();\r\n    } else {\r\n      open();\r\n    }\r\n  }\r\n\r\n  function destroy() {\r\n    // Close dialog if open\r\n    if (isOpen) {\r\n      close();\r\n    }\r\n\r\n    // Remove event listeners\r\n    cleanupEventListeners();\r\n\r\n    // Remove ARIA attributes\r\n    removeAriaAttributes({\r\n      dialogEl,\r\n      triggers,\r\n    });\r\n\r\n    // Remove dialog API and initialization marker\r\n    delete dialogEl.dialogApi;\r\n    dialogEl.removeAttribute(\"data-dialog-initialized\");\r\n\r\n    // Clear any remaining cleanup\r\n    cleanupInteractOutside?.();\r\n    cleanupInteractOutside = null;\r\n  }\r\n\r\n  // Create keyboard handler\r\n  const keydownHandler = createKeyboardHandler(dialogEl, close, isOpenRef);\r\n\r\n  // Setup all event listeners and get cleanup function\r\n  const cleanupEventListeners = setupEventListeners({\r\n    triggers,\r\n    closers,\r\n    backdropEl,\r\n    dialogEl,\r\n    open,\r\n    close,\r\n    keydownHandler,\r\n  });\r\n\r\n  // Set initial state\r\n  if (defaultOpen) open();\r\n\r\n  // Create and attach API\r\n  const api = { open, close, toggle, destroy };\r\n  dialogEl.dialogApi = api;\r\n  dialogEl.setAttribute(\"data-dialog-initialized\", \"true\");\r\n\r\n  return api;\r\n}\r\n", "import {\r\n  addWFCustomPageLoadFeature,\r\n  afterWebflowReady,\r\n  getGsap,\r\n  getHtmlElement,\r\n  getMultipleHtmlElements,\r\n} from \"@taj-wf/utils\";\r\nimport { preventBodyScroll } from \"@zag-js/remove-scroll\";\r\n\r\nimport { PROPERTIES, SELECTORS } from \"@/utils/constants\";\r\nimport { createDialog } from \"@/utils/dialog\";\r\n\r\nlet dialogDestroyers: (() => void)[] = [];\r\n\r\nconst destroyDialogs = () => {\r\n  for (const destroy of dialogDestroyers) {\r\n    destroy();\r\n  }\r\n  dialogDestroyers = [];\r\n};\r\n\r\nconst initDialogs = () => {\r\n  const dialogWrappers = getMultipleHtmlElements({ selector: \"[data-dialog-id]\" });\r\n\r\n  if (!dialogWrappers) return;\r\n\r\n  const [gsap] = getGsap();\r\n\r\n  for (const dialogWrapper of dialogWrappers) {\r\n    const dialogId = dialogWrapper.getAttribute(PROPERTIES.dialogId)!;\r\n\r\n    const triggerEls = getMultipleHtmlElements({ selector: `[data-dialog-trigger=\"${dialogId}\"]` });\r\n\r\n    const closeEls = getMultipleHtmlElements({ selector: SELECTORS.close, parent: dialogWrapper });\r\n\r\n    if (!triggerEls || !closeEls) continue;\r\n\r\n    const backdropEl = getHtmlElement({ selector: SELECTORS.backdrop, parent: dialogWrapper });\r\n\r\n    if (!backdropEl) {\r\n      console.error(\"Dialog wrapper is missing backdrop element\", dialogWrapper);\r\n      continue;\r\n    }\r\n\r\n    const titleEl =\r\n      getHtmlElement({ selector: SELECTORS.title, parent: dialogWrapper }) || undefined;\r\n    const descriptionEl =\r\n      getHtmlElement({ selector: SELECTORS.desc, parent: dialogWrapper }) || undefined;\r\n\r\n    const smoothScroller = (document.body as HTMLBodyElement)?.smoothScroller;\r\n    let enableBodyScroll: (() => void) | undefined = undefined;\r\n\r\n    const dialog = createDialog({\r\n      dialogEl: dialogWrapper,\r\n      triggerEls,\r\n      closeEls,\r\n      titleEl,\r\n      descriptionEl,\r\n      disableScroll: () => {\r\n        if (smoothScroller) {\r\n          smoothScroller.disableScrolling();\r\n        } else {\r\n          enableBodyScroll = preventBodyScroll();\r\n        }\r\n      },\r\n      enableScroll: () => {\r\n        if (smoothScroller) {\r\n          smoothScroller.enableScrolling();\r\n        } else {\r\n          enableBodyScroll?.();\r\n        }\r\n      },\r\n      isGsapAvailable: !!gsap,\r\n    });\r\n\r\n    if (!dialog) {\r\n      console.error(\"Failed to create dialog for\", dialogWrapper);\r\n      continue;\r\n    }\r\n\r\n    const { destroy } = dialog;\r\n\r\n    dialogDestroyers.push(() => {\r\n      destroy();\r\n    });\r\n  }\r\n};\r\n\r\nafterWebflowReady(() => {\r\n  initDialogs();\r\n\r\n  addWFCustomPageLoadFeature({\r\n    name: \"CUSTOM_ACCESSIBLE_DIALOGS\",\r\n    async: false,\r\n    init: initDialogs,\r\n    destroy: destroyDialogs,\r\n    reInit: () => {\r\n      destroyDialogs();\r\n      initDialogs();\r\n    },\r\n  });\r\n});\r\n"],
  "mappings": "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",
  "names": ["gsap"]
}
